---
title: "L7-Functional Programming with purrr"
format: html
editor: visual
---

### Learning objectives

-   Be familiar with the concept of functional languages and functional styles of programming
-   Get comfortable with the major functions in purrr (e.g. the map family of functions)
-   Write your loops with map functions instead of the for loop

```{r}
# install.packages("purrr")
library(purrr)
```

## Characteristics of a functional language

### 1. First-class functions

```{r}
# 1.Assign a function to a variable (foo):
foo <- function(){
  return("This is foo.")
}

class(foo)
foo
foo()


# 2.You can store functions in a list:
foo_list <- list( 
  fun_1 = function() return("foo_1"),
  fun_2 = function() return("foo_2")
)

str(foo_list)
foo_list$fun_1()


# 3.You can pass functions as arguments to other functions:
shell_fn <- function(f) f() #f is a mapping here, default is null
shell_fn(foo_list$fun_1) #pass the function into shell_fn
shell_fn() # No input, return eror


# 4. Create functions inside of functions and return them as the result of a function
foo_wrap <- function(){
  foo_2 <- function(){
    return("This is foo_2.")
  }
  return(foo_2)
}

foo_wrap()
foo_wrap()()
(foo_wrap())()

```

### 2. Pure functions

To be clear, R is not formally a functional programming language as it does not require pure functions to be used when writing code.

The key idea of a ***functional style*** is this programming style encourages programmers to write a big function as many smaller isolated functions, where each function addresses one specific task.

```{r}
"data_set.csv" |> 
  import_data_from_file() |> 
  data_cleaning() |> 
  run_regression() |>
  model_diagnostics() |>
  model_visualization()

"data_set2.csv" |> 
  import_data_from_file() |> 
  data_cleaning() |> 
  run_different_regression() |>
  model_diagnostics() |>
  model_visualization()
```

## Functional style

At a high-level, a functional style is the concept of decomposing a big problem into smaller components, then solving each piece with a function or combination of functions.

### Functionals

In this lecture, we will focus on one type of functional technique, namely functionals, which are functions that take another function as an argument and returns a vector as output.

```{r}
randomise <- function(f) f(runif(1e3))
randomise(mean)
```

The most popular function in `purrr` is `map()` which iterates over the supplied data structure and apply a function during the iterations. Beside the `map()` function,`purrr` also offers a series of useful functions to manipulate the `list` data frame.

## **The `map` family**

The most fundamental functional in the `purrr` package is the `map(.x, .f)` function. It takes a vector (`.x`) and a function (`.f`), calls the function once for each element of the vector, and returns the results in a list. In other words, `map(1:3, f)` is equivalent to `list(f(1), f(2), f(3))`.

```{r}
library(purrr)

# we create a function called "triple"
triple <- function(x) x * 3

# using for loop to iterate over a vector
loop_ret <- list()
for(i in 1:3){
  loop_ret[i] <- triple(i)
}
loop_ret
```

```{r}
# map implementation to iterate over a vector
# please notate the input format: .x .f
map_eg1 <- map(.x = 1:3, .f = triple)
map_eg2 <- map(.x = 1:3, .f = function(x) triple(x)) # create an inline anonymous function
map_eg3 <- map(.x = 1:3, .f = ~triple(.x)) # same as above, but special purrr syntax with a "twiddle"

identical(loop_ret,map_eg1)
```

The base equivalent to `map(.x, .f)` is `lapply(X, FUN)`.

<div>

Attention! when the argument exists, the input format are different, especially like "\~"!

</div>

### **`map` variants**

There are four more specific variants of `map` that make it really a **family of functions** (of syntax `map_*()`).

-   `map_lgl()`

-   `map_int()`

-   `map_dbl()`

-   `map_chr()`

For example, `purrr` uses the convention that suffixes, like `_dbl()`, refer to the output. Each returns an atomic vector of the specified type: (Not the default output format, need to be defined)

```{r}
# map_chr() always returns a character vector
map_chr(.x = mtcars, .f = typeof)

# map_lgl() always returns a logical vector
map_lgl(.x = mtcars, .f = is.double)

# map_int() always returns a integer vector
n_unique <- function(x) length(unique(x))
temp1 = map(.x = mtcars, .f = n_unique)
temp2 = map_dbl(.x = mtcars, .f = n_unique)
class(temp1)
class(temp2) # change the output format from list to integer
```

<div>

All `map_*()` functions can take any type of vector as input. The examples above rely on two facts:

1.  `mtcars` is a `data.frame`. In R, `data.frame` is a special case of `list`, where each column as one item of the list. Don't confuse with each row as an item.

2.  All `map` functions always return an output vector the same length as the input, which implies that each call to `.f` must return a single value. If it does not, you will get an error:

</div>

```{r}
class(mtcars)
typeof(mtcars)

pair <- function(x) c(x, x)
map_dbl(.x = 1:2, .f = pair)
map_dbl(1:2, as.character)
map_dbl(1:2, as.character()) # as.character(): the original function we wrote
  # Question: as.character的函数格式是有什么不同之处吗？？？？？

```

```{r}
tmp_dat <- data.frame(
  x = 1:5,
  y = 6:10
)
map_dbl(tmp_dat, mean)

tmp_dat <- data.frame(
  x = 1:5,
  y = 6:10
) |> map_dbl(mean)
tmp_dat
```

### **Passing arguments with `...`**

```{r}
x <- list(1:5, c(1:10, NA))
map_dbl(x, ~ mean(.x, na.rm = TRUE))

# Simpler form
map_dbl(x, mean, na.rm = TRUE)
```

This is easiest to understand with a picture: any arguments that come after `f` in the call to `map()` are inserted *after* the data in individual calls to `f()`:

### **Stratified analysis with `map`**

Before we go on to explore more map variants, let's take a quick look at how you tend to use multiple `purrr` functions to solve a moderately realistic problem: fitting a model to each subgroup and extracting a coefficient of the model.

```{r}
# different numbers of cylinders
unique(mtcars$cyl) 

by_cyl <- split(mtcars, mtcars$cyl) # mtcars$cyl works as a factor
length(by_cyl)

str(by_cyl)
dim(by_cyl)
by_cyl
class(by_cyl) # list
class(by_cyl[1]) # list
class(by_cyl[1]$`4`) # data.frame
# This creates a list of three data frames: the cars with 4, 6, and 8 cylinders respectively.
```

This creates a list of three data frames: the cars with 4, 6, and 8 cylinders respectively.

```{r}
# Returns a list with output from each lm fit for each cylinder
by_cyl |>
  map(.f = ~ lm(mpg ~ wt, data = .x))

# extract the second coefficient (i.e. the slope).
# Using Loop function
slopes <- double(length(by_cyl))
for (i in seq_along(by_cyl)) {
  model <- lm(mpg ~ wt, data = by_cyl[[i]])
  slopes[[i]] <- coef(model)[[2]]
}
slopes

# Using map function
by_cyl |>
  map(.f = ~ lm(mpg ~ wt, data = .x)) |>
  map(.f = coef) |>
  map_dbl(2)
```

Now we are interested in calculating the average `mpg` for vehicles with different numbers of cylinders. How can we use `map` functions to do this? You can return a list.

```{r}
split(mtcars, unique(mtcars$cyl)) |>
  map_dbl(.f = ~mean(.x$mpg))

by_cyl |> 
  map_dbl(.f = ~mean(.x$mpg)) # returns a vector of doubles

```

**`map_dbl(2)`** 中的数字 **`2`** 表示函数 **`map_dbl`** 将应用于列表或向量中每个元素的第二个值。这是因为在这里，**`map_dbl`** 的参数是一个整数，指定要提取的元素的位置。

如果使用 **`map_dbl([2])`**，它将被解释为提取整个列表或向量中第二个元素。在这个具体的上下文中，这不是我们想要的，因为我们的目标是提取每个线性模型的系数向量中的第二个元素（截距项），而不是提取整个列表的第二个元素。

### **Matrix as the output**

It is also possible to return the the results as data frames by

-   row binding (`map_dfr`) or

-   column binding (`map_dfc`)

```{r}
by_cyl |> 
  map_dbl(.f = ~mean(.x$mpg)) # returns a vector of doubles

by_cyl |> 
  map_dfr(.f = ~colMeans(.x)) # return a data frame by row binding

by_cyl |> 
  map_dfc(.f = ~colMeans(.x)) # return a data frame by col binding
```

### More map variants

There are 23 primary variants of `map()`. So far, we have learned about five (`map()`, `map_lgl()`, `map_int()`, `map_dbl()` and `map_chr()`). That means that you have got 18 (!!) more to learn. That sounds like a lot, but fortunately the design of `purrr` means that you only need to learn five new ideas:

-   Output same type as input with `modify()`

-   Iterate over two inputs with `map2()`.

-   Iterate with an index using `imap()`

-   Return nothing with `walk()`.

-   Iterate over any number of inputs with `pmap()`.

```{r}

```
